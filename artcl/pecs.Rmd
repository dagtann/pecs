---
output:
    pdf_document:
        includes:
            in_header: header.tex
    documentclass: cup_PSRM
---

\markboth{GANGHOF, EPPNER, AND TANNEBERG}{Turnout and Pre-Electoral Coalitions}

```{r, optionsChunk, include = FALSE}
knitr::opts_chunk$set(
    cache = FALSE, eval = TRUE, echo = FALSE, fig.align = "center",
    fig.width = 12, fig.height = 8, warning = FALSE, message = FALSE
)
source("~/github/pecs/src/r/master.R")
```

<!-- \journalname{Draft Submission to Political Science Research and Methods}
\journalcopy{The European Political Science Association, 2019}
\fpage{X}
\lpage{XXX}
\journalvolume{6}
\journalissue{3}
\doinumber{doi:10.1017/psrm.2016.XX}
 -->

\author{Steffen Ganghof, Sebastian Eppner, Dag Tanneberg}
\title{Bring out the Rest\newline What pre-electoral coalitions increase turnout in national elections?}
\maketitle

# Introduction

What explains turnout in general elections with high numbers of competing parties?
After all, as the number of political parties increases coalition cabinets become
more likely whose format usually depends exclusively on the bargains struck in
parliament. ``The presence of many parties may mean that voters have little say in
the actual selection of the government'' \cite[118]{Blais.2006}, effectively
reducing the incentive to turn out and vote. Extant research suggests that
pre-electoral coalitions mitigate the adverse effect of multipartism as they
provide everyone with additional information on credible coalition options
\cite[197]{Smith.2018}. However, prior empirical tests of that argument
suffer from two non-negligble constraints. First, results are based on a small set
of countries and a limited number of elections. As a consequence, their
generalizability is questionable. Second, and more importantly, prior research
frequently aggregates data to the election level, disregarding information on
different types, electoral strength or prior incumbency of pre-electoral
coalitions. This paper presents new data on pre-electoral coalitions that have
higher temporal and spatial coverage and that allow closer scrutiny of each
covered pre-electoral coalition. The data highlight substantial differences
between pre-electoral coalitions and imply that only coalitions which formulate
a clear alternative to the incumbent government increase turnout in multiparty
elections.

# Why does multipartism decrease turnout?

# What pre-electoral coalitions increase government identifiability?

# Introducing the data

Following \cite{Golder.2006}, we regard as pre-electoral coalition any group of parties that publicly and mutually announces its intention to form or continue
a coalition government prior to election night. Obviously, such statements may
differ in their degree of commitment. Some coalitions do not even agree on
written terms whereas others present joint programs or field joint candidates.
We provide new and unprecedentedly granular data on
`r sprintf("%.0f", sum(country_panel$nupec_neu, na.rm=TRUE))` pre-electoral coalitions. Moreover, covering
`r sprintf("%.0f", length(unique(country_panel$election_id[!is.na(country_panel$in_lsvergl)])))` elections held between $1945$ and $2015$ in `r sprintf("%.0f", length(unique(country_panel$iso3c[!is.na(country_panel$in_lsvergl)])))` non-presidential democracies our data
provide the most complete survey of pre-electoral coalitions yet. Table \ref{tbl:summaryPecs} summarizes our data.

```{r, pecsSummaryTable, results = "asis"}
# EDA: Return basic data information table
rm(list = ls()[!(ls() %in% clean_workspace)])
packs <- c("lubridate", "stargazer")
missing <- which(!(packs %in% rownames(installed.packages())))
if (any(missing)) {
    cat("Installing missing packages: ", packs[missing], "\n")
    install.packages(packs[missing], dependencies = TRUE)
}
for (p in packs) library(p, character.only = TRUE, quietly = TRUE)

# Constants
col_names <- c("Country", "First election", "Last election",
    "# Elections", "# PECs", "Min", "Med", "Max"
)


# Data objects
tmp <- as_tibble(filter(country_panel, in_lsvergl == 1)) %>%
    mutate(edate = ymd(election_date)) %>%
    group_by(iso3c)
first_election <- summarize_at(tmp, vars(edate), min) %>%
    rename("first_election" = edate)
last_election <- summarize_at(tmp, vars(edate), max) %>%
    rename("last_election" = edate)
n_elections <- summarize_at(tmp, vars(edate), function(x) length(unique(x))) %>%
    rename("n_elections" = edate)
n_pecs <- summarize_at(tmp, vars(nupec_neu), sum) %>%
    rename("n_pecs" = nupec_neu)
range_n_pecs <- summarize_at(tmp, vars(nupec_neu),
    .funs = list(min = min, median = median, max = max)
)
tmp <- plyr::join_all(
    list(first_election, last_election, n_elections, n_pecs, range_n_pecs),
    by = "iso3c", type = "inner"
)
tmp <- tmp[with(tmp, order(n_pecs)), ]
names(tmp) <- col_names


# Return table
stargazer(
    tmp,
    title = "Summary of pre-electoral coalitions and elections by country",
    label = "tbl:summaryPecs",
    summary = FALSE, style = "apsr", header = FALSE, rownames = FALSE
)


# housekeeping
for (p in packs) detach(paste("package", p, sep = ":"), character.only = TRUE)
rm(list = ls()[!(ls() %in% clean_workspace)])
```

For each country in our data, Table \ref{tbl:summaryPecs} reports the total number
of elections and pre-electoral coalitions included as well as for each the
minimum,  median, and maximum count of contending PECs.


```{r, tablePecsByType, eval = FALSE}
# This snippet returns the data required to reproduce table "XXX"
rm(list = ls()[!(ls() %in% clean_workspace)])

# functions
flag_nas <- function(r) all(is.na(r))

# data objects
pecs <- read_dta(
    file.path(path_project, "dta", "raw", "PEC_raw_stable15_2.dta"),
    encoding = "latin1"
)

# constants
pec_indicators <- grep("^[pec1-9]{4}$", names(pecs), perl = TRUE, value = TRUE)
suffixes <- c("type", "prog", "incumbent", "ea")
pec_indicators_2_aggregate <- character(0)
for (suffix in suffixes) {
    pec_indicators_2_aggregate <- append(
        pec_indicators_2_aggregate, paste(pec_indicators, suffix, sep = "_")
    )
}

# filter data
# (a) remove parties that did not enter PECs
pecs[, "no_pecs"] <- apply(pecs[, pec_indicators], 1, flag_nas)
pecs <- filter(pecs, !no_pecs)
# (b) aggregate to single pec entry per election
tmp <- subset(pecs, select = c("election_id", pec_indicators_2_aggregate))
tmp <- aggregate(
    x = as.data.frame(tmp[, -1]),
    by = list(election_id = tmp[["election_id"]]),
    FUN = function(x) ifelse(all(is.na(x)), NA, max(x, na.rm = TRUE))
)
# sanity check: n type codings <= nupec_neu
sum(!is.na(tmp[, paste(pec_indicators, "type", sep="_")])) <=
    sum(country_panel$nupec_neu, na.rm = TRUE)
# sanity check: n is.na(type) + n !(is.na(type)) == nupec_neu
sum(apply(tmp[, paste(pec_indicators, "type", sep="_")], 1, flag_nas)) +
    sum(!is.na(tmp[, paste(pec_indicators, "type", sep="_")])) ==
    sum(country_panel$nupec_neu, na.rm = TRUE)
# FAILS! 29 all NA entries, should be 12
tmp[apply(tmp[, paste(pec_indicators, "type", sep="_")], 1, flag_nas), 1]
# Elections in question: 20 166 171 205 227 284 291 306 357 386 403 407 453 479
# 496 508 596 606 623 643 653 664 709 710 711 712 713 715 782

# sanity checks: n codings <= sum of nupec_neu?
sum(!is.na(tmp[, paste(pec_indicators, "incumbent", sep="_")]))
sum(!is.na(tmp[, paste(pec_indicators, "prog", sep="_")]))
sum(!is.na(tmp[, paste(pec_indicators, "ea", sep="_")]))
# All pass

# sanity checks: n is.na(suffixes) + n !(is.na(suffixes)) == nupec_neu
sum(apply(tmp[, paste(pec_indicators, "incumbent", sep="_")], 1, flag_nas)) +
    sum(!is.na(tmp[, paste(pec_indicators, "incumbent", sep="_")])) # fails
sum(apply(tmp[, paste(pec_indicators, "prog", sep="_")], 1, flag_nas)) +
    sum(!is.na(tmp[, paste(pec_indicators, "prog", sep="_")])) # fails
sum(apply(tmp[, paste(pec_indicators, "ea", sep="_")], 1, flag_nas)) +
    sum(!is.na(tmp[, paste(pec_indicators, "ea", sep="_")])) # fails
# This test fails every time. Something about the test must be wrong

# create table
for (suffix in suffixes) {
    selection <- paste(pec_indicators, suffix, sep = "_")
    assign(suffix, gather(tmp[, selection], "pec", "value", selection)[[2]])
    # names(suffix, character.only = TRUE)
}
type <- factor(type, seq(6), c("Nomination agreement", "Joint list",
    "Dual-ballot instructions", "Vote transfer instructions", "Public commitment",
    "other"
    )
)
for (i in suffixes[-1]){
    assign(i, factor(get(i), 0:1, c("No", "Yes")))
}
lapply(mget(suffixes), function(x) cumsum(table(x)) / sum(table(x)))

# housekeeping
rm(list = ls()[!(ls() %in% clean_workspace)])
```

```{r, edaPecOverTime}
rm(list = ls()[!(ls() %in% clean_workspace)])


# Prep plot data
nupec_per_year <- aggregate( # How many PECs per year?
    nupec_neu ~ year,
    data = subset(country_panel, in_lsvergl == 1), FUN = sum
)
nelec_per_year <- aggregate(  # How many elections per year?
    election_id ~ year, data = subset(country_panel, in_lsvergl == 1),
    FUN = function(x) length(x)
)
perc_pec_per_year <- filter(country_panel, in_lsvergl == 1) %>%
    # relative freq of PECs in elections per year
    select(year, nupec_neu) %>%
    mutate(pec = ifelse(nupec_neu > 0, 1, 0)) %>%
    group_by(year) %>%
    summarise_at(vars(pec), mean)
mean_vshare_pec_per_year <- filter(country_panel, in_lsvergl == 1) %>%
    select(year, pectotal_neu) %>%
    group_by(year) %>%
    summarise_at(vars(pectotal_neu), mean, na.rm = TRUE)
pdta <- plyr::join_all(
    list(
        nupec_per_year, nelec_per_year, perc_pec_per_year, mean_vshare_pec_per_year
    ),
    by = "year", type = "inner"
)
pdta <- gather(pdta, "key", "value", nupec_neu, election_id, pec, pectotal_neu)
pdta <- within(pdta,
    key_labels <- factor(as.character(key),
        levels = c("nupec_neu", "election_id", "pec", "pectotal_neu"),
        labels = c("No. of PECs", "No. of elections",
            "Share elections with PECs", "Mean vote share for PECs"
        )
    )
)


# Return plot
ggplot(data = pdta, aes(x = year, y = value)) +
    geom_bar(stat = "identity", width = .9) +
    facet_grid(key_labels ~ ., scales = "free_y") +
    scale_x_continuous(breaks = seq(1945, 2015, 10)) +
    labs(y = "Frequency") +
    theme(axis.title.x = element_blank())

# housekeeping
rm(list = ls()[!(ls() %in% clean_workspace)])
```

\begin{table}[htb]
    \centering
    \caption{Summary of pre-electoral coalition properties}
    \label{tbl:SummaryPecProperties}
    \begin{tabular}{ll*{3}{c}}
    \toprule
    Attribute & Value & Freq. & Cum. Freq. & Cum. Rel. Freq.\\
    \midrule
    Type & Nomination agreement & 72 & 72 & 0.14\\
        ~ & Joint list & 204 & 276 & 0.63\\
        ~ & Dual-ballot instructions & 1 & 277 & 0.64\\
        ~ & Vote transfer instructions & 24 & 301 & 0.69\\
        ~ & Public commitment & 119 & 420 & 0.96\\
        ~ & Other & 16 & 436 & 1.00\\
    \midrule
    Joint program & No & 233 & 233 & 0.54\\
        ~ & Yes & 197 & 430 & 1.00\\
    \midrule
    Incumbent coalition & No & 337 & 337 & 0.77\\
        ~ & Yes & 99 & 436 & 1.00\\
    \midrule
    Electoral alliance & No & 83 & 83 & 0.71\\
        ~ & Yes & 34 & 117 & 1.00\\
    \bottomrule
    \end{tabular}
\end{table}


# Results



# Discussion

# Conclusion
