---
output:
    pdf_document:
        includes:
            in_header: header.tex
    documentclass: cup_PSRM
---

\markboth{GANGHOF, EPPNER, AND TANNEBERG}{Turnout and Pre-Electoral Coalitions}

```{r, optionsChunk, include = FALSE}
knitr::opts_chunk$set(
    cache = FALSE, eval = TRUE, echo = FALSE, fig.align = "center",
    fig.width = 12, fig.height = 8, warning = FALSE, message = FALSE
)
source("~/github/pecs/src/r/master.R")
```

<!-- \journalname{Draft Submission to Political Science Research and Methods}
\journalcopy{The European Political Science Association, 2019}
\fpage{X}
\lpage{XXX}
\journalvolume{6}
\journalissue{3}
\doinumber{doi:10.1017/psrm.2016.XX}
 -->

\author{Steffen Ganghof, Sebastian Eppner, Dag Tanneberg}
\title{Bring out the Rest\newline What pre-electoral coalitions increase turnout in national elections?}
\maketitle

# Introduction

What explains turnout in general elections with high numbers of competing parties?
After all, as the number of political parties increases coalition cabinets become
more likely whose format usually depends exclusively on the bargains struck in
parliament. ``The presence of many parties may mean that voters have little say in
the actual selection of the government'' \cite[118]{Blais.2006}, effectively
reducing the incentive to turn out and vote. Extant research suggests that
pre-electoral coalitions mitigate the adverse effect of multipartism as they
provide everyone with additional information on credible coalition options
\cite[197]{Smith.2018}. However, prior empirical tests of that argument
suffer from two non-negligble constraints. First, results are based on a small set
of countries and a limited number of elections. As a consequence, their
generalizability is questionable. Second, and more importantly, prior research
frequently aggregates data to the election level, disregarding information on
different types, electoral strength or prior incumbency of pre-electoral
coalitions. This paper presents new data on pre-electoral coalitions that have
higher temporal and spatial coverage and that allow closer scrutiny of each
covered pre-electoral coalition. The data highlight substantial differences
between pre-electoral coalitions and imply that only coalitions which formulate
a clear alternative to the incumbent government increase turnout in multiparty
elections.

# Why does multipartism decrease turnout?

# What pre-electoral coalitions increase government identifiability?

# Results

## Replication

\cite{Tillman.2015} marshalls a standard fixed-effects panel design in order to
study the effect of pre-electoral coalitions on turnout in general elections.
In the causal craze of this day and age fixed-effects designs have become the
"gold standard" \cite[139]{Bell.2015} in many fields because they eliminate
heterogeneity bias. More precisely, using data transformations such as, e.g.,
demeaning or first-differencing, fixed-effects designs remove time-invariant
unit-specific unobservables, i.e. permanent properties not realized in the
sample \cite[508]{Halaby.2004}, and they yield unbiased estimators of a
hypothesized causal effect as long as the disturbances are mean-independent of
the independent variable(s) across \textit{all} measurement occasions
\cite[482]{Wooldridge.2009}. Notwithstanding, there is a number of
misspecifications which fixed-effects designs are ill-equipped for. Scholars
should distrust fixed-effects estimators whenever there is reason to suspect
"the presence of any dynamic misspecification or omitted time-varying
variables" including trends among other things \cite[26]{Pluemper.2018}. Using
a number of different approaches, the following section demonstrates that a
shared trend in turnout and the presence of pre-electoral coalitions biases
most of Tillman's original results, even though there remains reason to believe
that some PECs are more important than others.

\textbf{Explain why shared trends bias results} \Blindtext[1][1]

```{r, edaNonStationarity, fig.cap="Non-Stationarity in the Data", fig.lp="fig:"}
rm(list = ls()[!(ls() %in% clean_workspace)])
pdta <- filter(country_panel, in_tillman == 1) %>%
    select(iso3c, year, turnout, pec1, vote_pec) %>%
    mutate(turnout = turnout / 100, vote_pec = vote_pec / 100)
tmp <- aggregate(
    pdta[, c("turnout", "pec1", "vote_pec")],
    list(year = pdta[["year"]]),
    FUN = mean, na.rm = TRUE
)
tmp[, "statistic"] <- "mu"
tmp2 <- aggregate(
    pdta[, c("turnout", "pec1", "vote_pec")],
    list(year = pdta[["year"]]),
    FUN = sd, na.rm = TRUE
)
tmp2[, "statistic"] <- "sigma"
pdta <- bind_rows(tmp, tmp2) %>%
    gather("key", "value", turnout, pec1, vote_pec) %>%
    mutate(
        key_labels = factor(
            key, levels = c("turnout", "pec1", "vote_pec"),
            labels = c("Turnout", "PEC contested", "Vote PEC")
        ),
        statistic_labels = factor(statistic, levels = c("mu", "sigma"),
                labels = c("Mean", "Std. Dev.")
            )
    )
ggplot(data = pdta, aes(x = year, y = value)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE, formula = y ~ poly(x, 3), colour = "black", size = .7) +
    facet_grid(statistic_labels ~ key_labels) +
    labs(caption = "Note: Features rescaled to unit-ranges. Cubic polynomials added."
    ) +
    ggthemes::theme_fivethirtyeight()
```

Figure \ref{fig:edaNonStationarity} highlights the potential for
non-stationarity in Tillman's data on turnout and pre-electoral coalitions. It
plots the mean (top row) and standard deviation (bottom row) for each of the
three key variables against time. Cubic polynomials characterize potential
trends in those first and second moments across time. If the data are
stationary, then their mean and variance will only randomly
fluctuate.\footnote{In fact, stationarity implies that a distribution is does
not change in \textit{any} of its moments.} However, Figure
\ref{fig:edaNonStationarity} implies systematic time-dependencies. First,
in line with extant research average turnout has declined for the past fourty
years. Starting at 88 per cent in 1970, it reaches an all-time low at 66 per
cent in the year 2000 and shows no strong sign of reversion until the end of the
observation period. Second, pre-electoral coalitions exhibit a more complex,
though not entirely unrelated trend. As shown in the middling panel of the top
row, PECs become more prevalent until the mid-1980s. Later on, their attraction
nosedives and continously declines -- in tandem with turnout. Voting results for
PECs as well as the variance in each indicator do not exhibit such clear-cut
patterns. Notwithstanding, the gist of Tillman's argument critically
depends on the information voters receive when PECs form, and
Figure \ref{fig:edaNonStationarity} suggests that the supporting evidence of
this argument may be entirely spurious.

Advocates of pre-electoral coalitions should not prematurely abondon ship,
though, as the preceeding analysis does not account for unit heterogenity.
The 22 parliamentary democracies in the data differ substantially with regard
to the (dis-)incentives they provide for voter turnout and pre-electoral
coalition bargains among political parties. For instance, compulsory voting in
Luxembourg has all but immunized the country from the blatant decrease
in turnout across established democracies. Moreover, firmly majoritarian
electoral systems such as the British FPP provide stronger incentives for the
formation of pre-electoral coalitions than proportional systems
\cite{Golder.2006}. Hence, the earlier impression of shared trends in turnout
and the formation of pre-electoral coalitions may entirely be driven by the
very reason that motivates fixed-effects models in the first place: unobserved
heterogeneity among the units.


```{r, reportDetrendedResults, fig.cap="Detrended Effect Estimates", fig.lp="fig:"}
rm(list = ls()[!(ls() %in% clean_workspace)])
packages <- c("plm", "sandwich", "lmtest", "texreg")
for(i in packages){
    if(!(i %in% rownames(installed.packages()))) {
        cat("Now installing required package:\t", i)
        install.packages(i, dependencies = TRUE)
    }
    library(i, character.only = TRUE)
}


# Declare Functions
extract_results <- function (model, of.interest = NULL, pcse = "group") {
    out <- cbind(beta = coef(model), se = sqrt(diag(vcov(model))))
    if(!is.null(pcse)) {
        out[, "se"] <- sqrt(diag(plm::vcovBK(model, cluster = pcse)))
    }
    if (!is.null(of.interest)) {
        out <- out[grep(of.interest, rownames(out), perl=TRUE), ]
    }
    return(out)
}


# Declare string constants
panel_id <- c("country", "year2")
control <- paste(
    c("enep", "disprop * pr", "plurality * closeness", "growth", "lnincome"),
    collapse = " + "
)
treatments <- c("PEC contested" = "pec1", "Vote PEC" = "vote_pec")
response <- "turnout"
trends <- c("None"="None", "Two-way Error\nComponent"="twoways",
    "First\nDifference"="fd", "Common\nTrend"="t",
    "Unit-specific\nTrend"="t*iso3c", "Lagged DV"="turnout_l1"
)


# Prepare data
data_to_fit <- filter(country_panel, (in_tillman == 1) & 
    !(iso3c %in% c("LUX", "CAN"))
) %>%
    group_by(iso3c) %>%
    mutate(turnout_l1 = dplyr::lag(turnout, n = 1, order_by = year2)) %>%
    ungroup()
data_to_fit <- pdata.frame(data_to_fit, index = c("iso3c", "year2"))


# Fit models
fitted_models <- list()
for (trend in trends){
    for(treatment in treatments) {
        assign(
            "frm",
            paste0(response, " ~ ", paste(treatment, control, trend, sep=" + "))
        )
        if (trend == "None") {
            assign(
                "frm", 
                paste0(response, " ~ ", paste(treatment, control, sep=" + "))
            )
        }
        if (trend == c("twoways")) {
            assign(
                "frm",
                paste0(response, " ~ ", paste(treatment, control, sep=" + "))
            )
            fitted_models[[paste(trend, treatment, sep = "_")]] <- plm(
                as.formula(frm), effect="twoways", model="within", data=data_to_fit
            )
            next
        }
        if (trend == c("fd")) {
            assign(
                "frm",
                paste0(response, " ~ ", paste(treatment, control, sep = " + "))
            )
            fitted_models[[paste(trend, treatment, sep = "_")]] <- plm(
                as.formula(frm), effect="individual", model="fd", data=data_to_fit
            )
            next
        }
        fitted_models[[paste(trend, treatment, sep = "_")]] <- plm(
            as.formula(frm), model = "within", data = data_to_fit
        )
    }
}


# Generate coefficient plot
to_plot <- vapply(fitted_models[c(1:4, 7:12)],
    FUN=extract_results, FUN.VALUE=numeric(2), of.interest="pec"
)
to_plot <- cbind(
    to_plot, vapply(fitted_models[c("fd_pec1", "fd_vote_pec")],
    FUN = function(model){
        out <- cbind(beta = coef(model), se = sqrt(diag(vcov(model))))
        out <- out[grep("pec", rownames(out), perl=TRUE), ]
        return(out)
    },
    FUN.VALUE = numeric(2)
    )
)
to_plot <- t(to_plot)
treatment_locations <- str_locate(rownames(to_plot), "vote_pec$|pec1$")
treatment_labels <- str_sub(rownames(to_plot), treatment_locations)
treatment_labels <- factor(treatment_labels, treatments, names(treatments))
trend_labels <- str_split_fixed(rownames(to_plot), "vote_pec|pec1", 2)[, 1]
trend_labels <- str_sub(trend_labels, 1, str_locate(trend_labels, "_$")[, 1]-1)
trend_labels <- factor(trend_labels, trends, names(trends))
z <- qnorm(c(.1, .05) / 2, lower = FALSE)
pdta <- tibble(beta=to_plot[, "beta"], se=to_plot[, "se"],
    trend_label=trend_labels, treatment_label=treatment_labels
) %>%
    mutate(lower90 = beta - z[1] * se, upper90 = beta + z[1] * se) %>%
    mutate(lower95 = beta - z[2] * se, upper95 = beta + z[2] * se)
ggplot(data = pdta, aes(x = trend_label, y = beta)) +
    geom_linerange(aes(ymin = lower95, ymax = upper95)) + 
    geom_linerange(aes(ymin = lower90, ymax = upper90), size=1.1) +
    geom_point(size = 2, shape = 21, fill = "white") +
    labs(x = "Detrending Strategy", y = expression(hat(beta)),
        caption = "Note: CIs at 90 and 95 per cent."
    ) +
    facet_grid(treatment_label ~ ., scales = "free") +
    ggthemes::theme_fivethirtyeight() +
    theme(axis.title = element_text(), axis.title.x = element_blank())


# Return BTON
ses <- lapply(fitted_models[c(1:4, 7:12)], vcovBK, cluster = "group")
ses[["fd_pec1"]] <- vcov(fitted_models[["fd_pec1"]])
ses[["fd_vote_pec"]] <- vcov(fitted_models[["fd_vote_pec"]])
ses <- ses[names(fitted_models)]
pvals <- lapply(names(fitted_models),
    function(x) coeftest(fitted_models[[x]], vcov = ses[[x]])[, 4]
)
names(pvals)
names(pvals) <- names(fitted_models)
texreg(
    fitted_models, 
    file = file.path(path_project, "artcl", "detrended_models.tex"),
    digits = 2,
    omit.coef = "(t:)",
    override.se = lapply(ses, function(x){sqrt(diag(x))}),
    override.p = pvals,
    custom.coef.names = c("PEC contested", "Parties", "Disproportionality", "PR",
        "Plurality", "Closeness", "Economic Growth", "log(income)",
        "Disproportionality $\\times$ PR",  "Plurality $\\times$ Closeness",
        "Vote PEC", "Constant", "$t$", "Turnout$_{t-1}$"
    ),
    reorder.coef = c(1, 11, 2:10, 13, 14, 12),
    booktabs = TRUE, sideways = TRUE,
    stars = c(0.001,  0.01, 0.05, 0.1),
    caption = "Replication Results",
    label = "tbl:ReplicationResults",
    custom.note = "Panel corrected SEs in parantheses \\cite{Beck.1995}, clustered by country. %stars."
)
# Manual edits to BTON
tmp <- readLines(file.path(path_project, "artcl", "detrended_models.tex"))
tmp <- tmp[!(tmp == "")]  # drop empty strings
tmp <- tmp[!grepl("\\usepackage", tmp)]  # drop usepackage entries
tmp[grepl("[a-z]\\_[a-z]", tmp)] <- paste(
    "Detrending Technique", "\\multicolumn{2}{c}{None}",
    "\\multicolumn{2}{c}{2way EC}",
    "\\multicolumn{2}{c}{FD}",
    "\\multicolumn{2}{c}{Common Trend}",
    "\\multicolumn{2}{c}{Unit-specific Trend}",
    "\\multicolumn{2}{c}{LDV} \\\\",
    sep = " & "
)  # replace table header
writeLines(tmp, con = file.path(path_project, "artcl", "detrended_models.tex"))


# housekeeping
for (p in packages) detach(paste("package", p, sep = ":"), character.only = TRUE)
rm(list = ls()[!(ls() %in% clean_workspace)])
```

\include{detrended_models}

## Exploratory Analysis: What PECs matter?

```{r, tablePecsByType, eval = FALSE}
# This snippet returns the data required to reproduce table "XXX"
rm(list = ls()[!(ls() %in% clean_workspace)])

# functions
flag_nas <- function(r) all(is.na(r))

# data objects
pecs <- read_dta(
    file.path(path_project, "dta", "raw", "PEC_raw_stable15_2.dta"),
    encoding = "latin1"
)

# constants
pec_indicators <- grep("^[pec1-9]{4}$", names(pecs), perl = TRUE, value = TRUE)
suffixes <- c("type", "prog", "incumbent", "ea")
pec_indicators_2_aggregate <- character(0)
for (suffix in suffixes) {
    pec_indicators_2_aggregate <- append(
        pec_indicators_2_aggregate, paste(pec_indicators, suffix, sep = "_")
    )
}

# filter data
# (a) remove parties that did not enter PECs
pecs[, "no_pecs"] <- apply(pecs[, pec_indicators], 1, flag_nas)
pecs <- filter(pecs, !no_pecs)
# (b) aggregate to single pec entry per election
tmp <- subset(pecs, select = c("election_id", pec_indicators_2_aggregate))
tmp <- aggregate(
    x = as.data.frame(tmp[, -1]),
    by = list(election_id = tmp[["election_id"]]),
    FUN = function(x) ifelse(all(is.na(x)), NA, max(x, na.rm = TRUE))
)
# sanity check: n type codings <= nupec_neu
sum(!is.na(tmp[, paste(pec_indicators, "type", sep="_")])) <=
    sum(country_panel$nupec_neu, na.rm = TRUE)
# sanity check: n is.na(type) + n !(is.na(type)) == nupec_neu
sum(apply(tmp[, paste(pec_indicators, "type", sep="_")], 1, flag_nas)) +
    sum(!is.na(tmp[, paste(pec_indicators, "type", sep="_")])) ==
    sum(country_panel$nupec_neu, na.rm = TRUE)
# FAILS! 29 all NA entries, should be 12
tmp[apply(tmp[, paste(pec_indicators, "type", sep="_")], 1, flag_nas), 1]
# Elections in question: 20 166 171 205 227 284 291 306 357 386 403 407 453 479
# 496 508 596 606 623 643 653 664 709 710 711 712 713 715 782

# sanity checks: n codings <= sum of nupec_neu?
sum(!is.na(tmp[, paste(pec_indicators, "incumbent", sep="_")]))
sum(!is.na(tmp[, paste(pec_indicators, "prog", sep="_")]))
sum(!is.na(tmp[, paste(pec_indicators, "ea", sep="_")]))
# All pass

# sanity checks: n is.na(suffixes) + n !(is.na(suffixes)) == nupec_neu
sum(apply(tmp[, paste(pec_indicators, "incumbent", sep="_")], 1, flag_nas)) +
    sum(!is.na(tmp[, paste(pec_indicators, "incumbent", sep="_")])) # fails
sum(apply(tmp[, paste(pec_indicators, "prog", sep="_")], 1, flag_nas)) +
    sum(!is.na(tmp[, paste(pec_indicators, "prog", sep="_")])) # fails
sum(apply(tmp[, paste(pec_indicators, "ea", sep="_")], 1, flag_nas)) +
    sum(!is.na(tmp[, paste(pec_indicators, "ea", sep="_")])) # fails
# This test fails every time. Something about the test must be wrong

# create table
for (suffix in suffixes) {
    selection <- paste(pec_indicators, suffix, sep = "_")
    assign(suffix, gather(tmp[, selection], "pec", "value", selection)[[2]])
    # names(suffix, character.only = TRUE)
}
type <- factor(type, seq(6), c("Nomination agreement", "Joint list",
    "Dual-ballot instructions", "Vote transfer instructions", "Public commitment",
    "other"
    )
)
for (i in suffixes[-1]){
    assign(i, factor(get(i), 0:1, c("No", "Yes")))
}
lapply(mget(suffixes), function(x) cumsum(table(x)) / sum(table(x)))

# housekeeping
rm(list = ls()[!(ls() %in% clean_workspace)])
```

\begin{table}[htb]
    \centering
    \caption{Summary of pre-electoral coalition properties}
    \label{tbl:SummaryPecProperties}
    \begin{tabular}{llccc}
    \toprule
    Attribute & Value & Freq. & Cum. Freq. & Cum. Rel. Freq.\\
    \midrule
    Type & Nomination agreement & 72 & 72 & 0.14\\
        ~ & Joint list & 204 & 276 & 0.63\\
        ~ & Dual-ballot instructions & 1 & 277 & 0.64\\
        ~ & Vote transfer instructions & 24 & 301 & 0.69\\
        ~ & Public commitment & 119 & 420 & 0.96\\
        ~ & Other & 16 & 436 & 1.00\\
    \midrule
    Joint program & No & 233 & 233 & 0.54\\
        ~ & Yes & 197 & 430 & 1.00\\
    \midrule
    Incumbent coalition & No & 337 & 337 & 0.77\\
        ~ & Yes & 99 & 436 & 1.00\\
    \bottomrule
    \end{tabular}
\end{table}


# Discussion

# Conclusion

# Appendix

## Country-level trends

```{r, edaCommonTrend, fig.cap="Secular Trends in the Data", fig.lp="fig:"}
rm(list = ls()[!(ls() %in% clean_workspace)])

max_degree = 3
raw_scores <- select(tillman, country, year, turnout_wi, pec1_wi, vote_pec_wi)

sigma_wi <- group_by(raw_scores, country) %>%
    summarise_at(.vars = vars(turnout_wi, pec1_wi, vote_pec_wi),
        .funs = list(sigma = sd)
    )
z_scores <- left_join(raw_scores, sigma_wi, by = "country") %>%
    mutate(turnout_wi_z = turnout_wi / turnout_wi_sigma) %>%
    mutate(pec1_wi_z = pec1_wi / pec1_wi_sigma) %>%
    mutate(vote_pec_wi_z = vote_pec_wi / vote_pec_wi_sigma)
z_scores <- z_scores[, !grepl("[_wi, _sigma]$", names(z_scores), perl = TRUE)] # drop sigmas
z_scores_all <- apply(raw_scores[, -(1:2)], 2, scale)
colnames(z_scores_all) <- paste(colnames(z_scores_all), "z", sep="_")
z_scores_all <- cbind.data.frame(raw_scores[, 1:2], z_scores_all)
z_scores_all <- z_scores_all %>% mutate(country = "All")
pdta <- rbind.data.frame(z_scores, z_scores_all)

## Plot all trends
ggplot(data = pdta, aes(x = year)) +
    geom_smooth(aes(y = turnout_wi_z, linetype = "Turnout"),
        method = "lm", formula = y ~ poly(x, max_degree), se = FALSE, colour = "black", size = .7
    ) +
    geom_smooth(aes(y = pec1_wi_z, linetype = "Pre-Electoral Coalition Entry"),
        method = "lm", formula = y ~ poly(x, max_degree), se = FALSE, colour = "black", size = .7
    ) +
    geom_smooth(aes(y = vote_pec_wi_z, linetype = "Pre-Electoral Coalition Result"),
        method = "lm", formula = y ~ poly(x, max_degree), se = FALSE, colour = "black", size = .7
    ) +
    geom_rug(sides = "b") +
    scale_linetype_manual(values = rev(seq(3))) +
    facet_wrap(vars(country)) +
    labs(y = "Z-Standardized Within-Differences", linetype = "Cubic Polynomial for Trend in") +
    ggthemes::theme_fivethirtyeight(base_size = base_size * .75) +
    theme(
        axis.title = element_text(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        axis.title.x = element_blank(),
        legend.position = "bottom"
    )
```


## Coverage of our data on PECs

Following \cite{Golder.2006}, we regard as pre-electoral coalition any group of parties that publicly and mutually announces its intention to form or continue
a coalition government prior to election night. Obviously, such statements may
differ in their degree of commitment. Some coalitions do not even agree on
written terms whereas others present joint programs or field joint candidates.
We provide new and unprecedentedly granular data on
`r sprintf("%.0f", sum(country_panel$nupec_neu, na.rm=TRUE))` pre-electoral coalitions. Moreover, covering
`r sprintf("%.0f", length(unique(country_panel$election_id[!is.na(country_panel$in_lsvergl)])))` elections held between $1945$ and $2015$ in `r sprintf("%.0f", length(unique(country_panel$iso3c[!is.na(country_panel$in_lsvergl)])))` non-presidential democracies our data
provide the most complete survey of pre-electoral coalitions yet. Table \ref{tbl:summaryPecs} summarizes our data.

```{r, pecsSummaryTable, results = "asis"}
# EDA: Return basic data information table
rm(list = ls()[!(ls() %in% clean_workspace)])
packs <- c("lubridate", "stargazer")
missing <- which(!(packs %in% rownames(installed.packages())))
if (any(missing)) {
    cat("Installing missing packages: ", packs[missing], "\n")
    install.packages(packs[missing], dependencies = TRUE)
}
for (p in packs) library(p, character.only = TRUE, quietly = TRUE)

# Constants
col_names <- c("Country", "First election", "Last election",
    "# Elections", "# PECs", "Min", "Med", "Max"
)


# Data objects
tmp <- as_tibble(filter(country_panel, in_lsvergl == 1)) %>%
    mutate(edate = ymd(election_date)) %>%
    group_by(iso3c)
first_election <- summarize_at(tmp, vars(edate), min) %>%
    rename("first_election" = edate)
last_election <- summarize_at(tmp, vars(edate), max) %>%
    rename("last_election" = edate)
n_elections <- summarize_at(tmp, vars(edate), function(x) length(unique(x))) %>%
    rename("n_elections" = edate)
n_pecs <- summarize_at(tmp, vars(nupec_neu), sum) %>%
    rename("n_pecs" = nupec_neu)
range_n_pecs <- summarize_at(tmp, vars(nupec_neu),
    .funs = list(min = min, median = median, max = max)
)
tmp <- plyr::join_all(
    list(first_election, last_election, n_elections, n_pecs, range_n_pecs),
    by = "iso3c", type = "inner"
)
tmp <- tmp[with(tmp, order(n_pecs)), ]
names(tmp) <- col_names


# Return table
stargazer(
    tmp,
    title = "Summary of pre-electoral coalitions and elections by country",
    label = "tbl:summaryPecs",
    summary = FALSE, style = "apsr", header = FALSE, rownames = FALSE
)


# housekeeping
for (p in packs) detach(paste("package", p, sep = ":"), character.only = TRUE)
rm(list = ls()[!(ls() %in% clean_workspace)])
```

For each country in our data, Table \ref{tbl:summaryPecs} reports the total number
of elections and pre-electoral coalitions included as well as for each the
minimum,  median, and maximum count of contending PECs.


## Trends in PECs

```{r, edaPecOverTime, fig.cap="Distribution of PECs over Time"}
rm(list = ls()[!(ls() %in% clean_workspace)])


# Prep plot data
nupec_per_year <- aggregate( # How many PECs per year?
    nupec_neu ~ year,
    data = subset(country_panel, in_lsvergl == 1), FUN = sum
)
nelec_per_year <- aggregate(  # How many elections per year?
    election_id ~ year, data = subset(country_panel, in_lsvergl == 1),
    FUN = function(x) length(x)
)
perc_pec_per_year <- filter(country_panel, in_lsvergl == 1) %>%
    # relative freq of PECs in elections per year
    select(year, nupec_neu) %>%
    mutate(pec = ifelse(nupec_neu > 0, 1, 0)) %>%
    group_by(year) %>%
    summarise_at(vars(pec), mean)
pdta <- plyr::join_all(list(nupec_per_year, nelec_per_year, perc_pec_per_year),
    by = "year", type = "inner"
)
pdta <- gather(pdta, "key", "value", nupec_neu, election_id, pec)
pdta <- within(pdta,
    key_labels <- factor(as.character(key),
        levels = c("nupec_neu", "election_id", "pec"),
        labels = c("No. of PECs", "No. of elections", "Share elections with PECs")
    )
)


# Return plot
ggplot(data = pdta, aes(x = year, y = value)) +
    geom_bar(stat = "identity", width = .9) +
    facet_grid(key_labels ~ ., scales = "free_y") +
    scale_x_continuous(breaks = seq(1945, 2015, 10)) +
    labs(y = "Frequency") +
    theme(axis.title.x = element_blank())

# housekeeping
rm(list = ls()[!(ls() %in% clean_workspace)])
```

